#!/usr/bin/env zsh
# -*- vim:fenc=utf-8:et:sw=2:ts=2:sts=2
#
# Copyright (c) 2018 Enrico M. Crisostomo
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
#
setopt local_options
setopt local_traps
unsetopt glob_subst
unsetopt bash_rematch

set -o errexit
set -o nounset
set -o pipefail

PROGNAME=${0:t}
PROGDIR=${0:h}
BUG_REPORT=@PACKAGE_BUGREPORT@
PACKAGE_VERSION=@PACKAGE_VERSION@

typeset -A gh_config
typeset -r gh_auth_file_path=~/.gh_api
typeset -r gh_api_base_url=https://api.github.com

# getopts
typeset -a help_flag
typeset -a max_pages_flag
typeset -a org_flag
typeset -a repo_flag
typeset -a user_flag
typeset -a verbose_flag
typeset -a version_flag

# Curl configuration
typeset -a curl_headers
curl_headers+=( -H "Accept: application/vnd.github.v3+json" )
curl_headers+=( -H "User-Agent: github-api-client" )
typeset -a curl_options
typeset -r curl_full_header_file=$(mktemp)
typeset -r curl_full_response_file=$(mktemp)
typeset -r curl_last_header_file=$(mktemp)
typeset -r curl_last_response_file=$(mktemp)
typeset -a curl_options
curl_options=( -s -L --netrc-optional --xattr -w %{http_code} -o ${curl_last_response_file} -D ${curl_last_header_file} )
typeset -a curl_cmd
curl_cmd=( curl ${curl_options} )

# pagination
typeset -i gh_max_pages=3
gh_link_next=

# Output verbosity and logging
exec 4>/dev/null
exec 5>/dev/null

typeset -A log_levels=(info 4 debug 5)

trap '__trap' INT TERM EXIT

function __trap()
{
  local exit_code=$?
  trap - EXIT
  exec 4>&-
  exec 5>&-
  rm -f ${curl_full_header_file}
  rm -f ${curl_full_response_file}
  rm -f ${curl_last_header_file}
  rm -f ${curl_last_response_file}

  exit ${exit_code}
}

function gh_log()
{
  local log_level=${1:?Log level is required.}
  local log_message=${2:?Log message is required.}
  : ${log_levels[(i)${log_level}]:?Log level not found.}
  local log_fd=${log_levels[${log_level}]}

  printf -- "%s: %s\n" ${log_level} ${log_message} 1>&${log_fd}
}

# Program dependencies
typeset -a REQUIRED_PROGS=( curl jq )

function gac_check_required_programs()
{
  for p in ${REQUIRED_PROGS}
  do
    command -v ${p} > /dev/null 2>&1 ||
      {
        >&2 print "Cannot find required program: ${p}"
        exit 1
      }
  done
}

print_version()
{
  print "${PROGNAME} ${PACKAGE_VERSION}"
  print "Copyright (C) 2018 Enrico M. Crisostomo"
  print "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>."
  print "This is free software: you are free to change and redistribute it."
  print "There is NO WARRANTY, to the extent permitted by law."
  print
  print "Written by Enrico M. Crisostomo"

  exit 0
}

print_usage()
{
  print "${PROGNAME} ${PACKAGE_VERSION}"
  print
  print "Usage:"
  print "${PROGNAME} (options)* (path)*"
  print "${PROGNAME} -h"
  print "${PROGNAME} -v"
  print
  print "Options:"
  print " -h, --help     Print this message."
  print " -v, --verbose  Print verbose output."
  print "     --version  Print the program version."
  print
  print "See the man page for more information."
  print
  print "Report bugs to <https://github.com/emcrisostomo/github-api-client/issues>."
  print "${PROGNAME} home page: <https://github.com/emcrisostomo/github-api-client>."

  exit 0
}

function gh_init_config()
{
  [[ -r ${gh_auth_file_path} ]] || return;

  local gh_credentials_file=$(cat ${gh_auth_file_path} | grep -v "^[[:space:]]*#")

  for l in ${(f)gh_credentials_file}
  do
    if [[ ${l} =~ "^([[:alnum:]]+)=(.*)" ]]
    then
      gh_config+=(${match[1]} ${match[2]})
    else
      >&2 print "Invalid configuration: ${l}"
    fi
  done
}

function gh_config_has_property()
{
  (( $# == 1 )) ||
    {
      >&2 print "Invalid number of arguments: $#"
      exit 1
    }

  local property_name=$1

  gh_init_config

  if [[ -n ${gh_config[(i)${property_name}]} ]]
  then
    return 0
  else
    return 1
  fi
}

function gh_configure_credentials()
{
  local -i has_token
  local -i has_username
  local -i has_password

  gh_config_has_property "token"    && has_token=1
  gh_config_has_property "username" && has_username=1
  gh_config_has_property "password" && has_password=1

  (( ${has_username} )) && {
    gh_username=${gh_config[username]}
  }

  (( ${has_token} )) && (( ${has_password} )) &&
    {
      >&2 print "Token and password cannot be configured at the same time."
      return 1
    }

  (( ${has_token} )) &&
    {
      curl_headers+=( -H "Authorization: token ${gh_config[token]}")
    }

  (( ${has_username} && ${has_password} )) &&
    {
      curl_options+=( -u ${gh_config[username]}:${gh_config[password]} )
    }

  return 0
}

function curl_print_response()
{
  cat ${curl_full_response_file}
}

function get_link_next()
{
  gh_link_next=$(
    cat ${curl_last_header_file} | \
      grep "^Link" | \
      sed -e 's/^Link: *//' |
      awk '
        BEGIN { RS=","; FS="; "; OFS=": " }
        {
          sub(/^rel="/, "", $2); sub(/"$/, "", $2)
          sub(/^ *</, "", $1); sub(/>$/, "", $1)
          print $2, $1
        }' | \
          grep "^next:" | \
          sed -e 's/^next: *//' || true)
}

function curl_request()
{
  (( $# == 1 )) || (( $# == 2 )) || {
    >&2 print "Invalid number of arguments: $#"
    return 1
  }

  : > ${curl_full_header_file}
  : > ${curl_full_response_file}
  : > ${curl_last_header_file}
  : > ${curl_last_response_file}

  local curl_method
  local -a curl_request_options

  if (( $# == 1 ))
  then
    curl_method=GET
    gh_link_next=${1}
  else
    curl_method=${1}
    gh_link_next=${2}
  fi

  case ${curl_method} in
    DELETE) ;;
    GET) ;;
    POST) curl_request_options+=( -d @- ) ;;
    *) >&2 print "Unexpected verb:" ${curl_method}
       return 1
  esac

  local -i current_page=0
  while [[ -n ${gh_link_next} ]] && (( ${current_page} < ${gh_max_pages} ))
  do
    local curl_status=$(${curl_cmd} -X ${curl_method} ${curl_request_options} ${curl_headers} ${gh_link_next})

    case ${curl_status} in
      20*) ;;
      4*) ;&
      5*) >&2 print "Error: ${curl_status} received."
          >&2 printf "Response: "
          curl_print_response
          return 1
          ;;
      *) >&2 print "Unexpected status received:" ${curl_status}
         return 1
    esac

    cat ${curl_last_header_file} >> ${curl_full_header_file}
    cat ${curl_last_response_file} >> ${curl_full_response_file}

    get_link_next
    current_page=$((current_page + 1))
  done
}

function allow_no_args()
{
  (( $# == 0 )) ||
    {
      >&2 print "Invalid arguments:" $*
      return 1
    }
}

function do_create-repo()
{
  allow_no_args $*
  curl_request POST ${gh_api_base_url}/user/repos
}

function do_delete-repo()
{
  allow_no_args $*
  check_parameter_or_fail gh_repo repository
  check_parameter_or_fail gh_username username
  curl_request DELETE ${gh_api_base_url}/repos/${gh_username}/${gh_repo}
}

function do_list-commits()
{
  allow_no_args $*
  check_parameter_or_fail gh_repo repository
  check_parameter_or_fail gh_username username
  curl_request ${gh_api_base_url}/repos/${gh_username}/${gh_repo}/commits
  curl_print_response | jq -r '.[] | { sha: .sha, author: .commit.author, message: .commit.message }'
}

function do_list-repos()
{
  allow_no_args $*
  check_parameter_or_fail gh_username username
  curl_request ${gh_api_base_url}/users/${gh_username}/repos
  curl_print_response | jq -r '.[] | .name'
}

function do_list-my-repos()
{
  allow_no_args $*
  curl_request ${gh_api_base_url}/user/repos
  curl_print_response | jq -r '.[] | .name'
}

function do_list-contributors()
{
  allow_no_args $*
  check_parameter_or_fail gh_repo repository
  check_parameter_or_fail gh_username username
  curl_request ${gh_api_base_url}/repos/${gh_username}/${gh_repo}/contributors
  curl_print_response | jq -r '.[] | .login'
}

function do_list-tags()
{
  allow_no_args $*
  check_parameter_or_fail gh_repo repository
  check_parameter_or_fail gh_username username
  curl_request ${gh_api_base_url}/repos/${gh_username}/${gh_repo}/tags
  curl_print_response | jq -r '.[] | .name'
}

function do_list-public-repos()
{
  allow_no_args $*
  curl_request ${gh_api_base_url}/repositories
  curl_print_response | jq -r '.[] | .full_name'
}

function do_list-repos()
{
  allow_no_args $*
  check_parameter_or_fail gh_username username
  curl_request ${gh_api_base_url}/users/${gh_username}/repos
  curl_print_response | jq -r '.[] | .name'
}

function check_parameter_or_fail()
{
  local param_name=${1:?Parameter name is required.}
  local display_name=${2:-${param_name}}

  (( ${(P)+${param_name}} )) ||
     {
       >&2 print "Missing parameter: "${display_name}
       return 1
     }
}

function do_list-org-repos()
{
  allow_no_args $*
  check_parameter_or_fail gh_organization organization
  curl_request ${gh_api_base_url}/orgs/${gh_organization}/repos
  curl_print_response | jq -r '.[] | .name'
}

function do_rate-limit()
{
  allow_no_args $*
  curl_request ${gh_api_base_url}/rate_limit
  curl_print_response | \
    jq \
      -r \
'"core remaining: \(.resources.core.remaining)
search remaining: \(.resources.search.remaining)
graphql remaining: \(.resources.graphql.remaining)"'
}

function __main()
{
  zparseopts -D -E \
             h=help_flag    -help=help_flag            \
                            -max-pages:=max_pages_flag \
             o:=org_flag    -organization:=org_flag    \
             r:=repo_flag   -repository:=repo_flag     \
             u:=user_flag   -username:=user_flag       \
             v=verbose_flag -verbose=verbose_flag      \
                            -version=version_flag

  (( ${+help_flag[1]} == 0 ))    || print_usage
  (( ${+version_flag[1]} == 0 )) || print_version

  # Temporary disable until deciding what to do with --netrc
  # gh_configure_credentials

  (( ${#max_pages_flag} ))      && gh_max_pages=${max_pages_flag[2]}
  (( ${#org_flag} ))            && gh_organization=${org_flag[2]}
  (( ${#repo_flag} ))           && gh_repo=${repo_flag[2]}
  (( ${#user_flag} ))           && gh_username=${user_flag[2]}
  (( ${+verbose_flag[1]} > 0 )) && VERBOSE_PRINT=print

  (( $# > 0 )) ||
    {
      >&2 print "Missing argument."
      exit 2
    }

  gh_command=$1
  shift

  if ! whence -w do_${gh_command} | grep "function$" > /dev/null
  then
    >&2 print "Unknown command:" ${gh_command}
    return 1
  fi

  do_${gh_command} $*
}

# main
__main $*

# Local variables:
# coding: utf-8
# mode: sh
# eval: (sh-set-shell "zsh")
# tab-width: 2
# indent-tabs-mode: nil
# sh-basic-offset: 2
# sh-indentation: 2
# End:
